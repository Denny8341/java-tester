/*
 * This file is generated by nl.griffelservices.proxy.Generator.
 * Please do not modify this file manually.
 * All your changes will be deleted when this file is regenerated.
 */
package nl.griffelservices.proxy.jdbc.impl;

import java.lang.reflect.Method;
import java.sql.Connection;

import nl.griffelservices.proxy.Handler;

/** This class is a proxy implementation of Connection */
@SuppressWarnings("unchecked")
public class ConnectionProxy extends JdbcProxy implements Connection {
	/**
	 * Constructs a new ConnectionProxy object.
	 * 
	 * @param handler
	 *            the proxy handler
	 * @param proxyObject
	 *            the proxy data
	 */
	public ConnectionProxy(Handler handler, Object proxyObject) {
		super(handler, Connection.class, proxyObject);
	}

	/**
	 * public abstract void Connection.setReadOnly(boolean) throws
	 * java.sql.SQLException
	 */
	private static final Method m0 = getMethod(Connection.class, "setReadOnly", new Class[] { boolean.class });

	public void setReadOnly(boolean p0) throws java.sql.SQLException {
		invoke(m0, new Object[] { new Boolean(p0) });
	}

	/**
	 * public abstract boolean Connection.isReadOnly() throws
	 * java.sql.SQLException
	 */
	private static final Method m1 = getMethod(Connection.class, "isReadOnly", new Class[] {});

	public boolean isReadOnly() throws java.sql.SQLException {
		return ((Boolean) invoke(m1, new Object[] {})).booleanValue();
	}

	/**
	 * public abstract void Connection.close() throws java.sql.SQLException
	 */
	private static final Method m2 = getMethod(Connection.class, "close", new Class[] {});

	public void close() throws java.sql.SQLException {
		invoke(m2, new Object[] {});
	}

	/**
	 * public abstract java.sql.DatabaseMetaData Connection.getMetaData() throws
	 * java.sql.SQLException
	 */
	private static final Method m3 = getMethod(Connection.class, "getMetaData", new Class[] {});

	public java.sql.DatabaseMetaData getMetaData() throws java.sql.SQLException {
		return (java.sql.DatabaseMetaData) invoke(m3, new Object[] {});
	}

	/**
	 * public abstract void Connection.clearWarnings() throws
	 * java.sql.SQLException
	 */
	private static final Method m4 = getMethod(Connection.class, "clearWarnings", new Class[] {});

	public void clearWarnings() throws java.sql.SQLException {
		invoke(m4, new Object[] {});
	}

	/**
	 * public abstract java.sql.SQLWarning Connection.getWarnings() throws
	 * java.sql.SQLException
	 */
	private static final Method m5 = getMethod(Connection.class, "getWarnings", new Class[] {});

	public java.sql.SQLWarning getWarnings() throws java.sql.SQLException {
		return (java.sql.SQLWarning) invoke(m5, new Object[] {});
	}

	/**
	 * public abstract void Connection.commit() throws java.sql.SQLException
	 */
	private static final Method m6 = getMethod(Connection.class, "commit", new Class[] {});

	public void commit() throws java.sql.SQLException {
		invoke(m6, new Object[] {});
	}

	/**
	 * public abstract java.sql.Statement
	 * Connection.createStatement(int,int,int) throws java.sql.SQLException
	 */
	private static final Method m7 = getMethod(Connection.class, "createStatement", new Class[] { int.class, int.class,
			int.class });

	public java.sql.Statement createStatement(int p0, int p1, int p2) throws java.sql.SQLException {
		return (java.sql.Statement) invoke(m7, new Object[] { new Integer(p0), new Integer(p1), new Integer(p2) });
	}

	/**
	 * public abstract java.sql.Statement Connection.createStatement() throws
	 * java.sql.SQLException
	 */
	private static final Method m8 = getMethod(Connection.class, "createStatement", new Class[] {});

	public java.sql.Statement createStatement() throws java.sql.SQLException {
		return (java.sql.Statement) invoke(m8, new Object[] {});
	}

	/**
	 * public abstract java.sql.Statement Connection.createStatement(int,int)
	 * throws java.sql.SQLException
	 */
	private static final Method m9 = getMethod(Connection.class, "createStatement",
			new Class[] { int.class, int.class });

	public java.sql.Statement createStatement(int p0, int p1) throws java.sql.SQLException {
		return (java.sql.Statement) invoke(m9, new Object[] { new Integer(p0), new Integer(p1) });
	}

	/**
	 * public abstract boolean Connection.getAutoCommit() throws
	 * java.sql.SQLException
	 */
	private static final Method m10 = getMethod(Connection.class, "getAutoCommit", new Class[] {});

	public boolean getAutoCommit() throws java.sql.SQLException {
		return ((Boolean) invoke(m10, new Object[] {})).booleanValue();
	}

	/**
	 * public abstract java.lang.String Connection.getCatalog() throws
	 * java.sql.SQLException
	 */
	private static final Method m11 = getMethod(Connection.class, "getCatalog", new Class[] {});

	public java.lang.String getCatalog() throws java.sql.SQLException {
		return (java.lang.String) invoke(m11, new Object[] {});
	}

	/**
	 * public abstract int Connection.getHoldability() throws
	 * java.sql.SQLException
	 */
	private static final Method m12 = getMethod(Connection.class, "getHoldability", new Class[] {});

	public int getHoldability() throws java.sql.SQLException {
		return ((Integer) invoke(m12, new Object[] {})).intValue();
	}

	/**
	 * public abstract int Connection.getTransactionIsolation() throws
	 * java.sql.SQLException
	 */
	private static final Method m13 = getMethod(Connection.class, "getTransactionIsolation", new Class[] {});

	public int getTransactionIsolation() throws java.sql.SQLException {
		return ((Integer) invoke(m13, new Object[] {})).intValue();
	}

	/**
	 * public abstract java.util.Map Connection.getTypeMap() throws
	 * java.sql.SQLException
	 */
	private static final Method m14 = getMethod(Connection.class, "getTypeMap", new Class[] {});

	public java.util.Map getTypeMap() throws java.sql.SQLException {
		return (java.util.Map) invoke(m14, new Object[] {});
	}

	/**
	 * public abstract boolean Connection.isClosed() throws
	 * java.sql.SQLException
	 */
	private static final Method m15 = getMethod(Connection.class, "isClosed", new Class[] {});

	public boolean isClosed() throws java.sql.SQLException {
		Object oo = invoke(m15, new Object[] {});
		return ((Boolean) oo).booleanValue();
	}

	/**
	 * public abstract java.lang.String Connection.nativeSQL(java.lang.String)
	 * throws java.sql.SQLException
	 */
	private static final Method m16 = getMethod(Connection.class, "nativeSQL", new Class[] { java.lang.String.class });

	public java.lang.String nativeSQL(java.lang.String p0) throws java.sql.SQLException {
		return (java.lang.String) invoke(m16, new Object[] { p0 });
	}

	/**
	 * public abstract java.sql.CallableStatement
	 * Connection.prepareCall(java.lang.String) throws java.sql.SQLException
	 */
	private static final Method m17 = getMethod(Connection.class, "prepareCall", new Class[] { java.lang.String.class });

	public java.sql.CallableStatement prepareCall(java.lang.String p0) throws java.sql.SQLException {
		return (java.sql.CallableStatement) invoke(m17, new Object[] { p0 });
	}

	/**
	 * public abstract java.sql.CallableStatement
	 * Connection.prepareCall(java.lang.String,int,int,int) throws
	 * java.sql.SQLException
	 */
	private static final Method m18 = getMethod(Connection.class, "prepareCall", new Class[] { java.lang.String.class,
			int.class, int.class, int.class });

	public java.sql.CallableStatement prepareCall(java.lang.String p0, int p1, int p2, int p3)
			throws java.sql.SQLException {
		return (java.sql.CallableStatement) invoke(m18, new Object[] { p0, new Integer(p1), new Integer(p2),
				new Integer(p3) });
	}

	/**
	 * public abstract java.sql.CallableStatement
	 * Connection.prepareCall(java.lang.String,int,int) throws
	 * java.sql.SQLException
	 */
	private static final Method m19 = getMethod(Connection.class, "prepareCall", new Class[] { java.lang.String.class,
			int.class, int.class });

	public java.sql.CallableStatement prepareCall(java.lang.String p0, int p1, int p2) throws java.sql.SQLException {
		return (java.sql.CallableStatement) invoke(m19, new Object[] { p0, new Integer(p1), new Integer(p2) });
	}

	/**
	 * public abstract java.sql.PreparedStatement
	 * Connection.prepareStatement(java.lang.String,java.lang.String[]) throws
	 * java.sql.SQLException
	 */
	private static final Method m20 = getMethod(Connection.class, "prepareStatement", new Class[] {
			java.lang.String.class, java.lang.String[].class });

	public java.sql.PreparedStatement prepareStatement(java.lang.String p0, java.lang.String[] p1)
			throws java.sql.SQLException {
		return (java.sql.PreparedStatement) invoke(m20, new Object[] { p0, p1 });
	}

	/**
	 * public abstract java.sql.PreparedStatement
	 * Connection.prepareStatement(java.lang.String,int[]) throws
	 * java.sql.SQLException
	 */
	private static final Method m21 = getMethod(Connection.class, "prepareStatement", new Class[] {
			java.lang.String.class, int[].class });

	public java.sql.PreparedStatement prepareStatement(java.lang.String p0, int[] p1) throws java.sql.SQLException {
		return (java.sql.PreparedStatement) invoke(m21, new Object[] { p0, p1 });
	}

	/**
	 * public abstract java.sql.PreparedStatement
	 * Connection.prepareStatement(java.lang.String,int,int,int) throws
	 * java.sql.SQLException
	 */
	private static final Method m22 = getMethod(Connection.class, "prepareStatement", new Class[] {
			java.lang.String.class, int.class, int.class, int.class });

	public java.sql.PreparedStatement prepareStatement(java.lang.String p0, int p1, int p2, int p3)
			throws java.sql.SQLException {
		return (java.sql.PreparedStatement) invoke(m22, new Object[] { p0, new Integer(p1), new Integer(p2),
				new Integer(p3) });
	}

	/**
	 * public abstract java.sql.PreparedStatement
	 * Connection.prepareStatement(java.lang.String) throws
	 * java.sql.SQLException
	 */
	private static final Method m23 = getMethod(Connection.class, "prepareStatement",
			new Class[] { java.lang.String.class });

	public java.sql.PreparedStatement prepareStatement(java.lang.String p0) throws java.sql.SQLException {
		return (java.sql.PreparedStatement) invoke(m23, new Object[] { p0 });
	}

	/**
	 * public abstract java.sql.PreparedStatement
	 * Connection.prepareStatement(java.lang.String,int) throws
	 * java.sql.SQLException
	 */
	private static final Method m24 = getMethod(Connection.class, "prepareStatement", new Class[] {
			java.lang.String.class, int.class });

	public java.sql.PreparedStatement prepareStatement(java.lang.String p0, int p1) throws java.sql.SQLException {
		return (java.sql.PreparedStatement) invoke(m24, new Object[] { p0, new Integer(p1) });
	}

	/**
	 * public abstract java.sql.PreparedStatement
	 * Connection.prepareStatement(java.lang.String,int,int) throws
	 * java.sql.SQLException
	 */
	private static final Method m25 = getMethod(Connection.class, "prepareStatement", new Class[] {
			java.lang.String.class, int.class, int.class });

	public java.sql.PreparedStatement prepareStatement(java.lang.String p0, int p1, int p2)
			throws java.sql.SQLException {
		return (java.sql.PreparedStatement) invoke(m25, new Object[] { p0, new Integer(p1), new Integer(p2) });
	}

	/**
	 * public abstract void Connection.releaseSavepoint(java.sql.Savepoint)
	 * throws java.sql.SQLException
	 */
	private static final Method m26 = getMethod(Connection.class, "releaseSavepoint",
			new Class[] { java.sql.Savepoint.class });

	public void releaseSavepoint(java.sql.Savepoint p0) throws java.sql.SQLException {
		invoke(m26, new Object[] { p0 });
	}

	/**
	 * public abstract void Connection.rollback(java.sql.Savepoint) throws
	 * java.sql.SQLException
	 */
	private static final Method m27 = getMethod(Connection.class, "rollback", new Class[] { java.sql.Savepoint.class });

	public void rollback(java.sql.Savepoint p0) throws java.sql.SQLException {
		invoke(m27, new Object[] { p0 });
	}

	/**
	 * public abstract void Connection.rollback() throws java.sql.SQLException
	 */
	private static final Method m28 = getMethod(Connection.class, "rollback", new Class[] {});

	public void rollback() throws java.sql.SQLException {
		invoke(m28, new Object[] {});
	}

	/**
	 * public abstract void Connection.setAutoCommit(boolean) throws
	 * java.sql.SQLException
	 */
	private static final Method m29 = getMethod(Connection.class, "setAutoCommit", new Class[] { boolean.class });

	public void setAutoCommit(boolean p0) throws java.sql.SQLException {
		invoke(m29, new Object[] { new Boolean(p0) });
	}

	/**
	 * public abstract void Connection.setCatalog(java.lang.String) throws
	 * java.sql.SQLException
	 */
	private static final Method m30 = getMethod(Connection.class, "setCatalog", new Class[] { java.lang.String.class });

	public void setCatalog(java.lang.String p0) throws java.sql.SQLException {
		invoke(m30, new Object[] { p0 });
	}

	/**
	 * public abstract void Connection.setHoldability(int) throws
	 * java.sql.SQLException
	 */
	private static final Method m31 = getMethod(Connection.class, "setHoldability", new Class[] { int.class });

	public void setHoldability(int p0) throws java.sql.SQLException {
		invoke(m31, new Object[] { new Integer(p0) });
	}

	/**
	 * public abstract java.sql.Savepoint
	 * Connection.setSavepoint(java.lang.String) throws java.sql.SQLException
	 */
	private static final Method m32 = getMethod(Connection.class, "setSavepoint",
			new Class[] { java.lang.String.class });

	public java.sql.Savepoint setSavepoint(java.lang.String p0) throws java.sql.SQLException {
		return (java.sql.Savepoint) invoke(m32, new Object[] { p0 });
	}

	/**
	 * public abstract java.sql.Savepoint Connection.setSavepoint() throws
	 * java.sql.SQLException
	 */
	private static final Method m33 = getMethod(Connection.class, "setSavepoint", new Class[] {});

	public java.sql.Savepoint setSavepoint() throws java.sql.SQLException {
		return (java.sql.Savepoint) invoke(m33, new Object[] {});
	}

	/**
	 * public abstract void Connection.setTransactionIsolation(int) throws
	 * java.sql.SQLException
	 */
	private static final Method m34 = getMethod(Connection.class, "setTransactionIsolation", new Class[] { int.class });

	public void setTransactionIsolation(int p0) throws java.sql.SQLException {
		invoke(m34, new Object[] { new Integer(p0) });
	}

	/**
	 * public abstract void Connection.setTypeMap(java.util.Map) throws
	 * java.sql.SQLException
	 */
	private static final Method m35 = getMethod(Connection.class, "setTypeMap", new Class[] { java.util.Map.class });

	public void setTypeMap(java.util.Map p0) throws java.sql.SQLException {
		invoke(m35, new Object[] { p0 });
	}
}
